---
title: "Sei's drum!"
author: "Michael Großbach"
date: Draft `r Sys.Date()`
output:
  html_document: 
    fig_caption: yes
    toc: yes
    toc_float: yes
    code_folding: hide
    fig_width: 3.5
    number_sections: yes
bibliography: asiams.bib
editor_options:
    chunk_output_type: console
---

```{r Libraries, message=FALSE}
library(brms)
library(dplyr)
library(ggplot2)
library(ggthemes)
library(kfigr)
library(knitr)
library(patchwork)
```

```{r Settings, echo=FALSE}
opts_chunk$set(comment = NULL,
               fig.width = 12,
               fig.height = 12, 
               echo = TRUE)
theme_set(theme_light())
knit_hooks$set(anchor = kfigr::hook_anchor)
opts_knit$set(kfigr.link = TRUE,
              kfigr.prefix = TRUE)
knitr::opts_chunk$set(fig.width = 3.5,
                      fig.height = 3.5)
options(mc.cores = parallel::detectCores())
rstan::rstan_options(auto_write = TRUE)
# Constants:
MODEL <- FALSE
FIGREF <- "Fig." # type for pics and plots, kfigr::figr()
TABREF <- "Tab." # type for tables, kfigr::figr()
MODREF <- "Model" # type for models, kfigr::figr()
PRIORREF <- "Prior" # type for priors, kfigr::figr()
SRCREF <- "Src." # type for source code blocks, kfigr::figr()
COLOR_BLIND_PALETTE <- RColorBrewer::brewer.pal(n = 9, name = "YlOrRd")
source("dahl_drumming_models.R")
```

The data set was read in as is, the columns `subj`, `arm`, `cond`, `series` and `no` were converted to factors, the column `filename` was deleted. A new column was added to the dataset, `patient`, based on the `subj` prefix ('P' or 'S'), with a '0' coding for healthy controls, and a '1' for patients.

```{r}
read.csv("features.csv") %>%
  mutate(filename = NULL,
         patient = factor(if_else(grepl("^P", 
                                        subj), 
                                  1L, 
                                  0L)),
         series = factor(series),
         subj = factor(subj),
         arm = factor(arm),
         cond = factor(cond),
         no = factor(no)) ->
  drum_beats
```

# Exploration

## Instruction Condition, and Arm Used

In a first attempt to get an overview, the descriptors' density estimates were plotted, broken down by `arm` and `cond`.

```{r DescriptorDensities, anchor=FIGREF, fig.width=12, fig.height=18}
dep_vars <- names(drum_beats)[which(!(names(drum_beats) %in% c("subj", 
                                                               "arm", 
                                                               "cond", 
                                                               "no",
                                                               "series",
                                                               "patient")))]
n_vars <- length(dep_vars)
  plot_lst <- vector("list", length = n_vars)
  plt_cnt <- 1
  for (dv in dep_vars) {
    if (plt_cnt == n_vars) {
      plt_pos <- c(2, 0.5)
    } else {
      plt_pos <- "none"
    }
    if (plt_cnt %% 4 == 1) {
      ylab <- "density"
    } else {
      ylab <- ""
    }
    plot_lst[[plt_cnt]] <- ggplot(drum_beats, 
                                  aes_string(x = dv, 
                                             color = "cond")) +
      geom_density(na.rm = TRUE) + 
      scale_color_colorblind() +
      ylab(ylab) +
      geom_rug(alpha = 0.25) + 
      theme(legend.position = plt_pos) +
      facet_wrap(~ arm)
    plt_cnt <- plt_cnt + 1
  }
  print(wrap_plots(plot_lst, 
                   ncol = 4) +
          plot_annotation(
            tag_levels = "A"))
```

`r figr("DescriptorDensities", type = FIGREF)`. *Descriptor densities along with raw data points (rug ticks on x axes), broken down by arm (dominant [D] vs non-dominant [ND]) and instruction condition (controlled = C, normal = N).*

***

Several peculiarities are immediately apparent from the plots in `r figr("DescriptorDensities")`:

* There are no substantial differences in the density distributions between normal (N) and controlled (C) strokes
* <strike>`attDur`, `LAT`, and `attFlat` have very few unique data values (see rug ticks at bottom of plots)</strike>
* Looking at the dominant arm alone <strike>(and excluding the vars `attDur`, `LAT`, and `attFlat` for the reason just mentioned)</strike>, the densities have a trend toward a larger variance in the controlled condition (in other words: a less pointed distribution) with additional or larger humps in the tails, respectively

The lack of any clear-cut differences in the raw data between conditions suggests that it will be hard to find any differences by modeling.

<strike>The limited number of unique values in the attack-related measures (*e.g.* `attDur` only has `r length(unique(drum_beats$attDur))` unique values in a total of `r nrow(drum_beats)` observations across all subjects, conditions, and sides; that's only `r round(length(unique(drum_beats$attDur)) / nrow(drum_beats) * 100)` percent!) suggests that rounding errors propagated through the calculations. This is probably due to very similar, *i.e.* highly automated, and short attack times combined with the given sampling frequency, resulting in few data points, which in course of the calculations result in the observed phenomenon. But I'm just guessing here, as I do not know anything about these descriptors and how they are calculated or interpreted. Judging by the range of values of, *i.e.*, `attDur` (`r round(range(drum_beats$attDur), 2)`ms, across both sides and conditions) and a sampling frequency of 48 kHz, this leaves us at 48 * (`r round(range(drum_beats$attDur), 2)[2]` - `r round(range(drum_beats$attDur), 2)[1]`) = `r round(48 * (range(drum_beats$attDur)[2] - range(drum_beats$attDur)[1]))` points to choose beginning and end of the attack. Given the supposed highly automatized motor program used to initiate the stroke, along with the laws of physics at play here (no pun intended), it is not very surprising to see very few unique values. My limited knowledge---or rather, my ignorance of anything sound-related---aside, from a statistical standpoint these measures do not seem suited to describe any differences between the experimental conditions investigated here.</strike> 

<strike>Given the very few data points in the attack phase, any descriptor derived from such a short period of time (*.e.g.*. `attSPL`) cannot be judged as being stable in the sense of being reproducible. Hence I suggest to drop all attack-derived descriptors.</strike>

```{r}
# drum_beats %>%
#   mutate(attDur = NULL,
#          LAT = NULL,
#          attSPL = NULL,
#          attSC = NULL,
#          attFlat = NULL,
#          attSpecFlat = NULL) ->
#   drum_beats
```

The increase in variance for the conditions N < C does not come as a surprise as I assume normal also means highly trained and thus automatized, whereas controlled involves less automatization and more 'individualness' both within and between subjects. 

### Conclusions

Looking at the above investigated descriptors and @Danielsen2015, it seems reasonable to limit the modeling attempts to `totDur`, `totSPL`, `totSC`, and `TC`. 

But Sofia wrote on 2020-07-09: "Francesco and I have discussed a bit related to descriptors and we want to concentrate on the “transient” period (although the name probably will change). Spectral Centroid (transSC) should be one, and I suggest transFlat for the other. Francesco, does that sound reasonable?"  

On 2020-07-22 both Sofia and Francesco agreed upon `transSC`, `transFlat`, and `transCrest` as the probably most important response variables to look at.

### Francesco's comments

Update: 

* The lack of data points for `attFlat` is fixed by solving a bug in the feature extraction: now the downsampling ratio for the envelope extraction is reduced, and makes the *MIRToolbox* algorithm less sensitive to frames with an rms value of 0 (which returns an incorrect value of 0, since we have a geometric mean at the numerator). Now we have a larger spread which allows high values (\sim 1 = peaky envelope, \sim 0 = smooth/flat envelope).
* The crest factor is now calculated for the separate phases.

Regarding the attack phase: I agree with the remarks regarding duration. Given the fact that we are not comparing different instruments, I wouldn't have expected a large variation. This is not surprising if we consider that our system is changing only slightly (same rototom, same drumstick, same action, a bit different tuning across subjects): in fact, the perceived timbral differences are so small that we are in trouble guessing on the descriptors.

The sampling frequency is even lower ($f_s = 44100$ Hz). Even if we had a higher sample rate which could reveal some discrepancies in the attack durations, we would have to prove that they are perceptually relevant.

Therefore, I am happy to discard `attDur` and `LAT` (which is obviously a log-transformed duration, only there for the sake of consistency with the literature).

I am a bit more in doubt when it comes to discarding all the attack descriptors. Even if what Michael says is true from a statistical point of view, we should still be able to discriminate timbre on short time windows due to the high temporal resolution of our hearing. Attack phase descriptors (with the same definition of attack that we are using, which is most likely not coincident with perceptual attack) are employed in @camara_effects_2020, and the Oslo group has a paper under construction which analyzes drum sounds in a similar manner (see *OsloPlots.png* in the OneDrive folder).

I am worried that merely taking the overall descriptors into account would introduce a lot of unnecessary and perceptually catching information --- mostly the tonal part of the signal, i.e. the drum ringing in the last part of the decay. That's why Sofia and I are suggesting to look at what we could call "main energy" or "early decay" phase (i.e. from max peak to temporal centroid).

Would it be feasible to set up 4 different models (i.e. one for each phase), at least in the univariate version?

As for the descriptors to include: although `TC` is employed in @Danielsen2015, the PDFs are even more similar. I would go for `Dur` (except attack?), `SPL`, `SC`, and one between `Flat`, `SpecFlat` or `Crest`.

My (informal and biased) listening tests tell me that, at least for some subjects, I hear a pattern going towards a harsher (controlled) vs smoother (normal) timbre exactly at the hit point, plus slightly less (controlled) or more pitch/amplitude fluctuation. Hopefully this could be catched by spectral centroid, specrtral/temporal flatness, or crest factor. This should be independent of SPL unless the subject misinterpreted the instructions, therefore SPL acts as a sort of control variable in our model.  

### Model Considerations

There are several points that need to be considered before making a decision regarding the type of modeling to be done in this study, (1) the sample size places restrictions on the external validity; (2) data from small samples can be better modeled when regularization is in place to 'tame' the estimates; (3) the hierarchical structure of the data (subjects played several trials with either their dominant or non-dominant arm under two conditions) suggests a multilevel analysis of the data which would, in addition to the Bayesian regularization via priors, also results in shrinkage of the estimates; (4) given the small distribution differences between the two experimental conditions, along with the 

1. Given the extremely small sample size, any attempt to fit the data using traditional statistics, a.k.a. null-hypothesis significance testing, would make us vulnerable to all kinds of criticism. I therefore suggest to use Bayesian statistics instead, as it allows us to estimate *probability distributions* of parameters rather than *confidence intervals* around point estimates, and thus embraces uncertainty in estimates. 
1. Additionally, Bayesian regression uses prior probability distributions to arrive at sensible estimates. These priors regularize estimates, or draw them toward zero, a desirable effect which has long been recognized even in traditional statistics (*e.g.* ridge regression and lasso; @Tibshirani1996).
1. ANOVA (or regression with grouping variables) requires each subject's trials to be averaged, say, within conditions or groups (or both), to be able to assess treatment effects; this results in the individual variation within a subject to get lost while it might have been very informative to include it in the analysis. Multilevel (or hierarchical) modeling allows to include the entire data structure (`r figr("MLMstructure", type = FIGREF)`) so that no information gets lost through averaging, but all variation (both individual and treatment-driven) propagates through the analysis and ends up in the final results, allowing for more realistic credibility margins around estimates. 
1. Variance in traditional statistics is considered to be fixed (think homoscedasticity in ANOVA, or the $\epsilon$ in regression formulas such as $y_i = \beta_0 + \beta_1x_i + \epsilon$), whereas it is an estimated quantity in Bayesian statistics and therefore can vary between conditions (or groups or subjects etc.) and thus capture varying variance in different conditions, or groups etc. 

```{r MLMstructure, anchor=FIGREF}
# chunk intentionally empty  
```

~~~
Group:                    Patient                       Healthy Control
                        /        \                     /               \
Instruction:    Normal        			Controlled   Normal        			    Controlled
                | |    \      			/ |    \
Player:         1 2 ... n			   1  2 ... n
               / \
Side   dominant non-dominant
        / | \	    / | \
Trial  1 ..  p     1  .. p
~~~

`r figr("MLMstructure")`. *The multilevel structure of a data set should be reflected in the analysis.*

***

### Conclusions

Will start with a simple univariate model, add predictors and interactions, then a bivariate model, and finally a quadruple-variate model and see where this leads us.

## Individual Responses

The humps in the density distributions in section [Instruction Condition, and Arm Used] made me curious where they might originate from. So in the following graph the density estimates of one of the descriptors, `transSC`, are plotted broken down by `subj`. and then also by `cond`, separately for patients and healthy subjects.

```{r DensIndivRespPlot, anchor=FIGREF}
ggplot(drum_beats, aes(transSC, 
                       color = subj, 
                       linetype = cond)) + 
  geom_density(alpha = 0.1) 
```

`r figr("DensIndivRespPlot", type = FIGREF)`. *`transSC` density distribution of participants, broken down by instruction condition.*

***

It is obvious that some participants do not differ substantially between the normal and the controlled condition, whereas others do, and even markedly so. Additionally, there seems to be quite a spread of the centers of distributions across a wide range of values, suggesting very individual drum sounds.

The wide distribution of centers of mass between individuals made me want to further break down the plot.

```{r DensIndivRespGroupedPlot, ancho=FIGREF}
ggplot(drum_beats, aes(transSC, 
                       color = subj, 
                       linetype = cond)) + 
  geom_density(alpha = 0.1) +
  facet_wrap(~ patient)
```

`r figr("DensIndivRespGrouped", type = FIGREF)`. *`transSC` density distribution of participants, broken down by instruction condition and group (patients and healthy subjects).*

***

The above plot is interesting in that it seems to show that the four healthy subjects were more uniform than the patients in their `transSC` distributions and also, with the exception of S2, had very similar `transSC` distributions for the normal and the controlled conditions. In the patients, two had very similar distributions in both conditions (P1 and P5), whereas the two others showed differing results for the two conditions. So with regard to Sofia's hypothesis (ch. [Modeling]) I'd argue, at least for `transSC` alone, having drummers play normal and controlled strokes would not allow subjects to tell the difference in a listening test. But maybe it would qualify as a screening test for movement disorders in drummers. Just a random thought.

While breaking it down it occurred to me that looking at individual variation (that is, between series) might also be enlightening.

```{r DensIndivSeriesGroupedPlot, anchor=FIGREF, fig.width=7}
ggplot(drum_beats, aes(transSC, 
                       color = cond, 
                       group = series)) + 
  geom_density(alpha = 0.1) +
  facet_wrap(~ subj, nrow = 2)
```

`r figr("DensIndivSeriesGroupedPlot", type = FIGREF)`. *Density plots of individual series.*

***


And it was! The plot in `r figr("DensIndivSeriesGroupedPlot")` made visible that P1 and P5 had consistently very low transSC values. P3 was consistent within the normal instruction condition, but had, on average, higher values, and with a lot more variation, in the controlled condition. P4 had more variation in both conditions, and higher transSC values in both; in other words, P4 was consistantly bad. (But then again: what do I know what bad is wrt `transSC`!)

The healthy subjects showed comparable variation and centers of mass within conditions, and all but one (S2) also across conditions.

Comparing the two rows of panels in `r figr("DensIndivSeriesGroupedPlot")` reveals that healthy subjects have *more* variation than the patients.

Although tempting, we probably shouldn't get carried away and generalize to the populations of healthy drummers and ones with movement disorders, respectively.

# Modeling

Sofia, on 2020-07-07: "The main hypothesis is that playing instruction (N/C) will affect the stroke in a way that is perceivable".

## Univariate Models

Looking at the variables agreed upon <strike>*I* have decided</strike> to use as response variables in the regression models<strike>---implying that this is by no means set in stone---</strike>, it seems like a skewed normal link function would be appropriate to model them.

Let's start with `transSC`<strike>`totDur`</strike>. Using an extended model description language [@Bates2010;@Buerkner2018], going back to Wilkinson and Rogers's [-@Wilkinson1973] modeling language, we write:

```{r}
(m0_form <-bf(transSC ~ 1 + (1 | subj)))
```

which claims that `transSC` is explained by ('~') an intercept, denoted by '1', and an additional term '(1 | subj)'. The '1' in parentheses again stands for the intercept, but the pipe '|' assigns an intercept to each level of the factor 'subj'. In this particular case this means that the model will estimate an individual intercept for each unique drummer listed in the data set column `subj`. These individual, or varying, intercepts are then used in informing the estimation of the population intercept.

Note: set `MODEL` to `TRUE` at the top of the script if you haven't compile/build your model yet.

```{r}
if (MODEL) {
  m0 <- brm(m0_form,
            family = skew_normal(),
            inits = "0",
            data = drum_beats)
  m0 <- add_criterion(m0, 
                      "loo",
                      reloo = TRUE)
  save(m0, 
       file = "m0.rda")
} else {
  load("m0.rda")
}
```

This null model is also termed unconditional model because it has no grouping structure apart from individuals--the 'subj' bit in the model equation above. There is some variation in every natural data set. To make sure, it's not just variation caused by different participants, we can calculate the intra-class correlation coefficient (ICC).

```{r}
m0_icc <- ICC(m0, "subj")
```

The Null model's ICC amounts to `r round(m0_icc, 2)`, which suggests that approx. `r round(m0_icc, 2) * 100` percent of the variation in the data set can be attributed to (or explained by) the grouping structure. This is highly unfortunate, as it does not leave a lot of variation to be explained by independent factors like instruction, or arm. The most likely reason for this high ICC value is the small sample size combined with high inter-individual variation. Small sample sizes combined with large trial numbers are less of a problem when subjects respond, on average, close to the population mean, even with large spread due to fluctuating alertness, increasing fatigue etc., *.e.g.* in reaction time paradigms. But here, with large intra- *and* inter-individual variation, this might become a problem.

***

`r figr("m0_summary", type = TABREF)`. *Model summary.*

```{r m0_summary, achor = TABREF}
(m0_summary <- summary(m0, 
                       priors = TRUE))
```

The intercept in `r figr("m0_summary")` amounts to roughly `r round(m0_summary$fixed["Intercept", "Estimate"])`. In this model specification, the intercept is identical to the data set average. The table also shows that the inter-individual standard deviation (`sd(Intercept)`) is large compared to the unexplained variation (`sigma`). This led to the large ICC value above. By adding more and more independent factors to the model specification, we will later try to decrease $\sigma$, *i.e.* 'explain away' as much remaining variation as possible. 

```{r m0_ppcheck, anchor=FIGREF}
pp_check(m0, nsamples = 100)
```

`r figr("m0_ppcheck", type = FIGREF)`. *Posterior predictive check. The thick blue line shows the distribution of the empirical data. The thin blue lines are one-hundred realizations of data generated from parameters estimated by the model.*

***

The posterior predictive plot in `r figr("m0_ppcheck")` gives an impression on how the null model would generate data, given the parameters it estimated from the empirical data. As the thick line deviates from the modeled thin lines, especially on the left and the right side of the peak of the distribution, it is apparent that the model can be improved.

```{r}
# conditional_effects(m0) 
```

### Group Model 

In this model, the intercept is complemented with second 'main' or population effect, the grouping variable `patient`:

```{r}
(m1_form <- bf(transSC ~ 1 + patient + 
                (1 | subj)))
```

I could have also specified the model without the explicit '1 + ', as the intercept is implicitly included in the model unless I explicitly exclude it. From now on I will always save some extra typing by refraining from explicitly indluding the intercept in models.

So now the model not only contains the individuals as grouping structure to 'explain away' variation, but also whether they belong to the patients or the healthy subjects.

The prior distributions in Bayesian models reflect the knowledge about the estimated parameters. The package `brms` automatically places weakly informative priors on parameters as soft contraints. But with more complex models involving varying parameter estimates, the statistical back end which does the heavy lifting, needs stronger priors particularly on these parameters, otherwise models don't converge. The parameters most vulnerable to outliers in the data are the varying effects parameters, or random effects in traditional statistics. Therefore we place a stronger prior probability distribution over the estimate of the SD of individual intercepts:

```{r}
(m1_prior <- set_prior("normal(0, 10)", class = "sd"))
```

and leave the rest of the priors as suggested by the package `brms` (see `r figr("m1_summary", type = TABREF)` for their priors).

```{r}
if (MODEL) {
  m1 <- brm(m1_form,
            prior = m1_prior,
            inits = "0",
            family = skew_normal(),
            data = drum_beats)
  m1 <- add_criterion(m1, 
                      "loo",
                      reloo = TRUE)
  save(m1, 
       file = "m1.rda")
} else {
  load("m1.rda")
}
```

***

`r figr("m1_summary")`. *Model summary.*

```{r m1_summary, achor = TABREF}
(m1_summary <- summary(m1, 
                       priors = TRUE))
```

The intercept in `r figr("m1_summary")` amounts to roughly `r round(m1_summary$fixed["Intercept", "Estimate"])`. In this model specification, the intercept is identical to the controlled strokes, while the `patient1` value is the mean of the posterior distribution *difference* between the healthy subjects and the patients (`r round(m1_summary$fixed["patient1", "Estimate"])`). The table also shows that the interindividual standard deviation (`sd(Intercept)` $\approx$ `r round(m1_summary$random$subj["sd(Intercept)", "Estimate"])` is still large compared to the unexplained variation (`sigma` $\approx$ `r round(m1_summary$spec_pars["sigma", "Estimate"])`). 

```{r m1_ppcheck, anchor=FIGREF}
pp_check(m1, nsamples = 100)
```

`r figr("m1_ppcheck", type = FIGREF)`. *Posterior predictive check. The thick blue line shows the distribution of the empirical data. The thin blue lines are one-hundred realizations of data generated from parameters estimated by the model.*

***

The posterior predictive plot in `r figr("m1_ppcheck")` gives an impression on how this model would generate data, given the parameters it estimated from the empirical data. There is not much change from `r figr("m0_ppcheck")`, which is not very surprising given the small estimated difference between the groups.

```{r}
conditional_effects(m1,
                    dpar = "mu")
```

### Group + Condition Model

In this model, the intercept is complemented with second 'main' or population effect, the instruction condition `cond`:

```{r}
(m2_form <-bf(transSC ~ patient + cond + 
                (1 | subj)))
```

So now the model also contains the individuals as grouping structure to 'explain away' variation, but also the manipulations.

The prior distributions in Bayesian models reflect the knowledge about the estimated parameters. The package `brms` automatically places weakly informative priors on parameters as soft contraints. But with more complex models involving varying parameter estimates, the statistical back end which does the heavy lifting, needs stronger priors particularly on these parameters, otherwise models don't converge. The parameters most vulnerable to outliers in the data are the varying effects parameters, or random effects in traditional statistics. Therefore we place a stronger prior probability distribution over the estimate of the SD of individual intercepts:

```{r}
(m2_prior <- c(set_prior("normal(0, 3)",   class = "sd"),
               set_prior("normal(0, 3)",   class = "sigma"),
               set_prior("normal(0, 2)",   class = "alpha")))
```

and leave the rest of the priors as suggested by the package `brms` (see `r figr("m2_summary", type = TABREF)` for their priors).

```{r}
if (MODEL) {
  m2 <- brm(m2_form,
            prior = m2_prior,
            family = skew_normal(),
            inits = "0",
            data = drum_beats)
  m2 <- add_criterion(m2, 
                      "loo",
                      reloo = TRUE)
  save(m2, 
       file = "m2.rda")
} else {
  load("m2.rda")
}
```

***

`r figr("m2_summary")`. *Model summary.*

```{r m2_summary, achor = TABREF}
(m2_summary <- summary(m2, 
                       priors = TRUE))
```

The intercept in `r figr("m2_summary")` amounts to roughly `r round(m2_summary$fixed["Intercept", "Estimate"])`. In this model specification, the intercept is identical to the controlled strokes, while the `condN` value is the mean of the posterior distribution *difference* between controlled and normal strokes (`r round(m2_summary$fixed["condN", "Estimate"])`). The table also shows that the interindividual standard deviation (`sd(Intercept)` $\approx$ `r round(m2_summary$random$subj["sd(Intercept)", "Estimate"])` is still large compared to the unexplained variation (`sigma` $\approx$ `r round(m2_summary$spec_pars["sigma", "Estimate"])`). 

```{r m2_ppcheck, anchor=FIGREF}
pp_check(m2, nsamples = 100)
```

`r figr("m2_ppcheck", type = FIGREF)`. *Posterior predictive check. The thick blue line shows the distribution of the empirical data. The thin blue lines are one-hundred realizations of data generated from parameters estimated by the model.*

***

The posterior predictive plot in `r figr("m2_ppcheck")` gives an impression on how this model would generate data, given the parameters it estimated from the empirical data. There is not much change from `r figr("m0_ppcheck")`, which is not very surprising given the small estimated difference between the conditions.

```{r}
conditional_effects(m2,
                    dpar = "mu")
```

### Group + ConditionVI Model

The last model included the instruction condition, more realistically reflecting the true structure of the data set. But it did not acknowledge that each subject executed several strokes in each of these conditions. This model includes a term with a varying intercept (VI) for condition to reflect just that, which will also assist in more realistically estimate the population effect of `cond`:

```{r}
(m3_form <- bf(transSC ~ patient + cond + 
                 (1 | subj) + 
                 (1 | cond)))
```

Including more varying parameters in the model requires the prior on them to be even stronger:

```{r}
(m3_prior <- m2_prior)
```

```{r}
if (MODEL) {
  m3 <- brm(m3_form,
            prior = m3_prior,
            family = skew_normal(),
            inits = "0",
            data = drum_beats)
  m3 <- add_criterion(m3, 
                      "loo",
                      reloo = TRUE)
  save(m3, 
       file = "m3.rda")
} else {
  load("m3.rda")
}
```

***

`r figr("m3_summary", type = TABREF)`. *Model summary.*

```{r m3_summary, achor = TABREF}
(m3_summary <- summary(m3, 
                       priors = TRUE))
```

The intercept in `r figr("m3_summary")` amounts to roughly `r round(m3_summary$fixed["Intercept", "Estimate"])`. In this model specification, the intercept is identical to the controlled strokes, while the `condN` value is the mean of the posterior distribution *difference* between controlled and normal strokes (`r round(m3_summary$fixed["condN", "Estimate"])`). The table also shows that the inter-individual standard deviation (`sd(Intercept)` $\approx$ `r round(m3_summary$random$subj["sd(Intercept)", "Estimate"])` is not large anymore compared to the unexplained variation (`sigma` $\approx$ `r round(m3_summary$spec_pars["sigma", "Estimate"])`). 

```{r m3_ppcheck, anchor=FIGREF}
pp_check(m3, nsamples = 100)
```

`r figr("m3_ppcheck", type = FIGREF)`. *Posterior predictive check. The thick blue line shows the distribution of the empirical data. The thin blue lines are one-hundred realizations of data generated from parameters estimated by the model.*

***

The posterior predictive plot in `r figr("m3_ppcheck")` gives an impression on how this model would generate data, given the parameters it estimated from the empirical data. There is not much change from `r figr("m0_ppcheck")`, which is not very surprising given the small estimated difference between the conditions.

```{r}
conditional_effects(m3,
                    dpar = "mu")
```

### Group x ConditionVI

The last model included the instruction condition, more realistically reflecting the true structure of the data set. But it did not acknowledge that each subject executed several strokes in each of these conditions. This model includes a term with a varying intercept (VI) for condition to reflect just that, which will also assist in more realistically estimate the population effect of `cond`:

```{r}
(m4_form <- bf(transSC ~ patient * cond + 
                 (1 | subj) + 
                 (1 | cond)))
```

Including more varying parameters in the model requires the prior on them to be even stronger:

```{r}
(m4_prior <- m3_prior)
```

```{r}
if (MODEL) {
  m4 <- brm(m4_form,
            prior = m4_prior,
            family = skew_normal(),
            inits = "0",
            data = drum_beats)
  m4 <- add_criterion(m4, 
                      "loo",
                      reloo = TRUE)
  save(m4, 
       file = "m4.rda")
} else {
  load("m4.rda")
}
```

***

`r figr("m4_summary", type = TABREF)`. *Model summary.*

```{r m4_summary, achor = TABREF}
(m4_summary <- summary(m4, 
                       priors = TRUE))
```

The intercept in `r figr("m4_summary")` amounts to roughly `r round(m4_summary$fixed["Intercept", "Estimate"])`. In this model specification, the intercept is identical to the controlled strokes, while the `condN` value is the mean of the posterior distribution *difference* between controlled and normal strokes (`r round(m4_summary$fixed["condN", "Estimate"])`). The table also shows that the inter-individual standard deviation (`sd(Intercept)` $\approx$ `r round(m4_summary$random$subj["sd(Intercept)", "Estimate"])` is not large anymore compared to the unexplained variation (`sigma` $\approx$ `r round(m4_summary$spec_pars["sigma", "Estimate"])`). 

```{r m4_ppcheck, anchor=FIGREF}
pp_check(m4, nsamples = 100)
```

`r figr("m4_ppcheck", type = FIGREF)`. *Posterior predictive check. The thick blue line shows the distribution of the empirical data. The thin blue lines are one-hundred realizations of data generated from parameters estimated by the model.*

***

The posterior predictive plot in `r figr("m4_ppcheck")` gives an impression on how this model would generate data, given the parameters it estimated from the empirical data. There is not much change from `r figr("m0_ppcheck")`, which is not very surprising given the small estimated difference between the conditions.

```{r}
conditional_effects(m4,
                    dpar = "mu")
```

### Group x ConditionVI + Arm Model


```{r}
(m5_form <- bf(transSC ~ patient * cond + arm +
                 (1 | subj) + 
                 (1 | cond)))
```


```{r}
(m5_prior <- m4_prior)
```

```{r}
if (MODEL) {
  m5 <- brm(m5_form,
            prior = m5_prior,
            family = skew_normal(),
            inits = "0",
            data = drum_beats)
  m5 <- add_criterion(m5, 
                      "loo",
                      reloo = TRUE)
  save(m5, 
       file = "m5.rda")
} else {
  load("m5.rda")
}
```

***

`r figr("m5_summary", type = TABREF)`. *Model summary.*

```{r m5_summary, achor = TABREF}
(m5_summary <- summary(m5, 
                       priors = TRUE))
```

In the Population-Level Effects section of `r figr("m5_summary")` are now two estimates for the skewness parameter alpha (one for the controlled [`alpha_Intercept`] and one for the normal condition [`alpha_condN`]), while there is no entry for alpha in the Family Specific section anymore. All this due to our explicit modeling of alpha conditional on instruction condition.

```{r m5_ppcheck, anchor=FIGREF}
pp_check(m5, nsamples = 100)
```

`r figr("m5_ppcheck", type = FIGREF)`. *Posterior predictive check. The thick blue line shows the distribution of the empirical data. The thin blue lines are one-hundred realizations of data generated from parameters estimated by the model.*

***

```{r}
conditional_effects(m5,
                    dpar = "mu")
```

### Group x Condition + ArmVI Model


```{r}
(m6_form <-bf(transSC ~ patient * cond + arm +
                (1 | subj) + 
                (1 | cond) + 
                (1 | arm)))
```


```{r}
(m6_prior <- m5_prior)
```

```{r}
if (MODEL) {
  m6 <- brm(m6_form,
            prior = m6_prior,
            family = skew_normal(),
            inits = "0",
            data = drum_beats)
  m6 <- add_criterion(m6, 
                      "loo",
                      reloo = TRUE)
  save(m6, 
       file = "m6.rda")
} else {
  load("m6.rda")
}
```

***

`r figr("m6_summary", type = TABREF)`. *Model summary.*

```{r m6_summary, achor = TABREF}
(m6_summary <- summary(m6, 
                       priors = TRUE))
```

In the Population-Level Effects section of `r figr("m6_summary")` are now two estimates for the skewness parameter alpha (one for the controlled [`alpha_Intercept`] and one for the normal condition [`alpha_condN`]), while there is no entry for alpha in the Family Specific section anymore. All this due to our explicit modeling of alpha conditional on instruction condition.

```{r m6_ppcheck, anchor=FIGREF}
pp_check(m6, nsamples = 100)
```

`r figr("m6_ppcheck", type = FIGREF)`. *Posterior predictive check. The thick blue line shows the distribution of the empirical data. The thin blue lines are one-hundred realizations of data generated from parameters estimated by the model.*

***

```{r}
# , fig.width=12
# wrap_plots(plot(conditional_effects(m6),
#              plot = FALSE)) +
#   plot_annotation(tag_levels = "A")
conditional_effects(m6,
                    dpar = "mu")
```

### Group x Condition x ArmVI Model


```{r}
(m6a_form <-bf(transSC ~ patient * cond * arm +
                 (1 | subj) + 
                 (1 | cond) + 
                 (1 | arm)))
```


```{r}
(m6a_prior <- m6_prior)
```

```{r}
if (MODEL) {
  m6a <- brm(m6a_form,
             prior = m6a_prior,
             family = skew_normal(),
             inits = "0",
             data = drum_beats)
  m6a <- add_criterion(m6a, 
                       "loo",
                       reloo = TRUE)
  save(m6a, 
       file = "m6a.rda")
} else {
  load("m6a.rda")
}
```

***

`r figr("m6a_summary", type = TABREF)`. *Model summary.*

```{r m6a_summary, achor = TABREF}
(m6a_summary <- summary(m6a, 
                       priors = TRUE))
```

In the Population-Level Effects section of `r figr("m6a_summary")` are now two estimates for the skewness parameter alpha (one for the controlled [`alpha_Intercept`] and one for the normal condition [`alpha_condN`]), while there is no entry for alpha in the Family Specific section anymore. All this due to our explicit modeling of alpha conditional on instruction condition.

```{r m6a_ppcheck, anchor=FIGREF}
pp_check(m6a, nsamples = 100)
```

`r figr("m6a_ppcheck", type = FIGREF)`. *Posterior predictive check. The thick blue line shows the distribution of the empirical data. The thin blue lines are one-hundred realizations of data generated from parameters estimated by the model.*

***

```{r m6a_conditionalPlots, fig.width=12}
# wrap_plots(plot(conditional_effects(m6a),
#                 plot = FALSE)) +
#     plot_annotation(tag_levels = "A")
```

```{r m6a_3_way_intPlots}
conditional_effects(m6a,
                    dpar = "mu")
conditions <- make_conditions(drum_beats, 
                              vars = "arm")
conditional_effects(m6a,
                    dpar = "mu",
                    effects = "patient:cond",
                    conditions = conditions)
```

### Modeling Condition-specific Variation

As is apparent from `r figr("DescriptorDensities")`, the controlled condition yielded broader density distributions in most descriptors. Hence, we model condition-dependent variation in the next model:

```{r}
(m7_form <-bf(transSC ~ patient * cond * arm + 
                (1 | subj) + 
                (1 | cond) +
                (1 | arm),
              sigma ~ cond))
```

This model has now two outcomes, not just one, as the models before. Spread is estimated as `sigma`, and it varies conditional on instruction condition.

Here's the non-standard (additional) prior:

```{r}
(m7_prior <- c(set_prior("normal(0, 5)", class = "sd"),
               set_prior("normal(0, 2)",  class = "alpha"),
               set_prior("normal(0, 10)", class = "Intercept", dpar = "sigma"),
               set_prior("normal(0, 10)", class = "b",         dpar = "sigma")
))
```

```{r}
if (MODEL) {
  m7 <- brm(m7_form,
            prior = m7_prior,
            family = skew_normal(),
            inits = "0",
            data = drum_beats)
  m7 <- add_criterion(m7, 
                      "loo",
                      reloo = TRUE)
  save(m7, 
       file = "m7.rda")
} else {
  load("m7.rda")
}
```

***

`r figr("m7_summary", type = TABREF)`. *Model summary.*

```{r m7_summary, achor = TABREF}
(m7_summary <- summary(m7, 
                       priors = TRUE))
```

In the Links section of the summary (`r figr("m7_summary")`) we note that sigma is no longer modeled on the identity scale but on the $\log_{2}$ scale. In the Population-Level Effects section of `r figr("m7_summary")` we now find not only the estimates for the Intercept and `condN` but also two estimates for sigma (one for the controlled [`sigma_Intercept`] and one for the normal condition [`sigma_condN`]). Because of this, there is no entry for sigma in the Family Specific section anymore. All this due to our explicit modeling of sigma conditional on instruction condition.

```{r m7_ppcheck, anchor=FIGREF}
pp_check(m7, nsamples = 100)
```

`r figr("m7_ppcheck", type = FIGREF)`. *Posterior predictive check. The thick blue line shows the distribution of the empirical data. The thin blue lines are one-hundred realizations of data generated from parameters estimated by the model.*

***

```{r m7_condPlot, anchor=FIGREF}
# , fig.width=12, fig.height=8
# p <- plot(conditional_effects(m7,
#                               dpar = "mu"),
#           plot = FALSE)
# p1 <- wrap_plots(p[[1]]+
#                    p[[2]] +
#                    p[[3]])
# p <- plot(conditional_effects(m7,
#                               dpar = "sigma"),
#           plot = FALSE)
# p2 <- wrap_plots(p[[1]]+
#                    p[[2]] +
#                    p[[3]])
# wrap_plots(p1, p2,
#            ncol = 1) +
#   plot_annotation(tag_levels = "A")
conditional_effects(m7,
                    dpar = "mu")
conditions <- make_conditions(drum_beats, 
                              vars = "arm")
conditional_effects(m7,
                    dpar = "mu",
                    effects = "patient:cond",
                    conditions = conditions)
conditional_effects(m7,
                    dpar = "sigma")
conditional_effects(m7,
                    dpar = "sigma",
                    effects = "patient:cond",
                    conditions = conditions)
```

`r figr("m7_condPlot", type = FIGREF)`. *Conditional plot.*

***

In `r figr("m7_condPlot")` we see a difference between the mean ('mu') estimated value for `transSC` depending on instruction condition (A), but no difference between dominant and non-dominant arm (B). Consequently, there is no interaction in (C).

The spread (`sigma`) of the estimated distributions also differs between conditions (D), but again not between arms (E). The latter is not surprising because we modeled sigma to vary conditional on condition, not arm.

### Modeling Arm-specific Skewness

At least in some descriptors in `r figr("DescriptorDensities")` the skewness of the distribution seems to change depending on the arm. The skew normal distribution is a generalization of the Gaussian distribution, allowing for the additional shape-parameter skewness (asymmetry) to vary. Hence, we model this side-dependent skewness in the next model:

```{r}
(m8_form <-bf(transSC ~ patient * cond * arm + 
                (1 | subj) + 
                (1 | cond) +
                (1 | arm),
              sigma ~ cond,
              alpha ~ arm))
```


```{r}
(m8_prior <- c(set_prior("normal(0, 3)",  class = "sd"),
               set_prior("normal(0, 10)", class = "Intercept", dpar = "sigma"),
               set_prior("normal(0, 10)", class = "b",         dpar = "sigma"),
               set_prior("normal(0, 2)",  class = "Intercept", dpar = "alpha"),
               set_prior("normal(0, 2)",  class = "b",         dpar = "alpha"))
)
```

```{r}
if (MODEL) {
  m8 <- brm(m8_form,
            prior = m8_prior,
            family = skew_normal(),
            inits = "0",
            data = drum_beats)
  m8 <- add_criterion(m8, 
                      "loo",
                      reloo = TRUE)
  save(m8, 
       file = "m8.rda")
} else {
  load("m8.rda")
}
```

***

`r figr("m8_summary", type = TABREF)`. *Model summary.*

```{r m8_summary, achor = TABREF}
(m8_summary <- summary(m8, 
                       priors = TRUE))
```

In the Population-Level Effects section of `r figr("m8_summary")` are now two estimates for the skewness parameter alpha (one for the dominant [`alpha_Intercept`] and one for the non-dominant arm [`alpha_armND`]), while there is no entry for alpha in the Family Specific section anymore. All this due to our explicit modeling of alpha conditional on arm.

```{r m8_ppcheck, anchor=FIGREF}
pp_check(m8, nsamples = 100)
```

`r figr("m8_ppcheck", type = FIGREF)`. *Posterior predictive check. The thick blue line shows the distribution of the empirical data. The thin blue lines are one-hundred realizations of data generated from parameters estimated by the model.*

***

```{r m8_condPlot, anchor=FIGREF}
# , fig.width=12, fig.height=12
# p <- plot(conditional_effects(m8,
#                               dpar = "mu"),
#           plot = FALSE)
# p1 <- wrap_plots(p[[1]] + xlab("") +
#                    p[[2]] + xlab("") + ylab("") +
#                    p[[3]] + xlab("") + ylab("") + theme(legend.position = "none"))
# p <- plot(conditional_effects(m8,
#                               dpar = "alpha"),
#           plot = FALSE)
# p2 <- wrap_plots(p[[1]] + xlab("") +
#                    p[[2]] + xlab("") + ylab("") +
#                    p[[3]] + xlab("") + ylab("") + theme(legend.position = "none"))
# p <- plot(conditional_effects(m8,
#                               dpar = "sigma"),
#           plot = FALSE)
# p3 <- wrap_plots(p[[1]] +
#                    p[[2]] + ylab("") +
#                    p[[3]] + ylab("") + theme(legend.position = "bottom"))
# wrap_plots(p1, p2, p3, 
#            ncol = 1) +
#   plot_annotation(tag_levels = "A")
conditional_effects(m8,
                    dpar = "mu")
conditions <- make_conditions(drum_beats, 
                              vars = "arm")
conditional_effects(m8,
                    dpar = "mu",
                    effects = "patient:cond",
                    conditions = conditions)
conditional_effects(m8,
                    dpar = "sigma")
conditional_effects(m8,
                    dpar = "sigma",
                    effects = "patient:cond",
                    conditions = conditions)
conditional_effects(m8,
                    dpar = "alpha")
conditional_effects(m8,
                    dpar = "alpha",
                    effects = "patient:cond",
                    conditions = conditions)
```

`r figr("m8_condPlot", type = FIGREF)`. *Conditional plots.*

***

In `r figr("m8_condPlot")` there is a clear difference in estimated mean ('mu') of $transSC$ conditional on instruction (A), but not on arm (B). Consequently, there is no interaction between instruction and arm (C). On the other hand, there is a difference in estimated skewness ('alpha') between sides (E), but not instructions (D). (F) follows from that. 'sigma' shows a clear difference between instructions (G), not so for side (H), which is mirrored in (I).

### Modeling Influence of Arm on Shape 

To be able to see whether skewness and spread are depending on both experimental manipulation and arm, the model formulas for 'sigma' and 'alpha' are updated accordingly:

```{r}
(m9_form <-bf(transSC ~ patient * cond * arm + 
                (1 | subj) + 
                (1 | cond) +
                (1 | arm),
              sigma ~ cond,
              alpha ~ arm))
```


```{r}
# (m8_prior <- c(set_prior("normal(0, 2)", class = "sd"),
#                set_prior("normal(0, 0.7)", class = "Intercept", dpar = "sigma"),
#                set_prior("normal(0, 0.7)", class = "sd",        dpar = "sigma"),
#                set_prior("normal(0, 2)", class = "Intercept", dpar = "alpha"),
#                set_prior("normal(0, 2)", class = "sd",        dpar = "alpha"))
# )
(m9_prior <- m8_prior)
```

```{r}
if (MODEL) {
  m9 <- brm(m9_form,
            prior = m9_prior,
            family = skew_normal(),
            inits = "0",
            data = drum_beats)
  m9 <- add_criterion(m9, 
                      "loo",
                      reloo = TRUE)
  save(m9, 
       file = "m9.rda")
} else {
  load("m9.rda")
}
```

***

`r figr("m9_summary", type = TABREF)`. *Model summary.*

```{r m9_summary, achor = TABREF}
(m9_summary <- summary(m9, 
                       priors = TRUE))
```

In the Population-Level Effects section of `r figr("m9_summary")` are now three estimates for the skewness parameter alpha, as well as three estimates for spread ('sigma').

```{r m9_ppcheck, anchor=FIGREF}
pp_check(m9, nsamples = 100)
```

`r figr("m9_ppcheck", type = FIGREF)`. *Posterior predictive check. The thick blue line shows the distribution of the empirical data. The thin blue lines are one-hundred realizations of data generated from parameters estimated by the model.*

***

```{r m9_condPlot, anchor=FIGREF}
# , fig.width=12, fig.height=12
# p <- plot(conditional_effects(m9, 
#                               dpar = "mu"),
#           plot = FALSE)
# p1 <- wrap_plots(p[[1]] + xlab("") +
#                    p[[2]] + xlab("") + ylab("") +
#                    p[[3]] + xlab("") + ylab("") +
#                    p[[4]] + xlab("") + ylab("") + theme(legend.position = "none") +
#                    p[[5]] + xlab("") + ylab("") + theme(legend.position = "none") +
#                    p[[6]] + xlab("") + ylab("") + theme(legend.position = "none"))
# p <- plot(conditional_effects(m9,
#                               dpar = "alpha"),
#           plot = FALSE)
# p2 <- wrap_plots(p[[1]] + xlab("") +
#                    p[[2]] + xlab("") + ylab("") +
#                    p[[3]] + xlab("") + ylab("") +
#                    p[[4]] + xlab("") + ylab("") + theme(legend.position = "none") +
#                    p[[5]] + xlab("") + ylab("") + theme(legend.position = "none") +
#                    p[[6]] + xlab("") + ylab("") + theme(legend.position = "none"))
# p <- plot(conditional_effects(m9,
#                               dpar = "sigma"),
#           plot = FALSE)
# p3 <- wrap_plots(p[[1]] +
#                    p[[2]] + ylab("") +
#                    p[[3]] + ylab("") +
#                    p[[4]] + ylab("") + theme(legend.position = "bottom") +
#                    p[[5]] + ylab("") + theme(legend.position = "bottom") +
#                    p[[6]] + ylab("") + theme(legend.position = "bottom"))
# wrap_plots(p1, p2, p3) +
#   plot_annotation(tag_levels = "A")
conditional_effects(m9,
                    dpar = "mu")
conditions <- make_conditions(drum_beats, 
                              vars = "arm")
conditional_effects(m9,
                    dpar = "mu",
                    effects = "patient:cond",
                    conditions = conditions)
conditional_effects(m9,
                    dpar = "sigma")
conditional_effects(m9,
                    dpar = "sigma",
                    effects = "patient:cond",
                    conditions = conditions)
conditional_effects(m9,
                    dpar = "alpha")
conditional_effects(m9,
                    dpar = "alpha",
                    effects = "patient:cond",
                    conditions = conditions)
```

`r figr("m9_condPlot", type = FIGREF)`. *Conditional plots. Had to take out all the fancy figure polishing, subplot lettering etc. Subplots are supposed to be numbered from A to ... starting in the top left corner, proceeding row-wise.* 

***

In `r figr("m9_condPlot")` the dots are the means of the posterior distributions of the respective estimate, and can be interpreted similarly to the point estimates in traditional frequentist statistics. The error bars represent 95% credible intervals, which are interpreted as comprising the true value with 95% probability, given the model and the data.

There is a difference in estimated the mean ('mu') of $transSC$ conditional on group (A) and condition (B), not so on arm (C). Likewise, there is a two-way  interaction between group and arm (D), but not between condition and arm (E). Consequently, there is no three-way interaction (F).

The remaining, unexplained variation 'sigma' shows a clear difference between instructions (H) and lesser so for side (I), but albeit their opposing trends, there is no interaction (J thru M).

There is a difference in estimated skewness ('alpha') both between instruction (O) and side (P), but with opposing trends. Nevertheless, there is no interaction between them (Q thru T). 

From a data-driven perspective this should lead to a simplification of the model, leaving out all the unnecessary interaction terms. A theory-driven approach though requires the final model to be 'full' in the sense that all explanatory variables must interact with all others, implying that not finding an interaction between factors either is due to there really not being an interaction--rendering the model mis-specified and proving the underlying theory wrong--, or due to insufficient data. Since the data set at hand is very small I vote to blame the failure to find interactions between all factors on the small sample size and would therefore keep all interactions in the model. 

### Model Comparison

We compare models by their estimated log-posterior density (elpd). The smaller this value the better a model predicts the data, despite the penalty for additional covariates. When the difference between two models is more than two SE apart they are considered to be 'different enough' to warrant acceptance of one over the other despite possibly smaller parsimony.

```{r}
univ_model_compar <- loo_compare(m0, m2, m3, m5, m6, m6a, m7, m8, m9)
print(univ_model_compar, simplify = T)
```

The model with the smallest `elpd` is `m9`, which corresponds to the last model (see [Modeling Influence of Instruction and Arm on Shape]). The difference between the best and the second-best model is `r round(univ_model_compar["m8", "elpd_diff"], 2)`, which is more than roughly two SE (2 x `r round(univ_model_compar["m8", "se_diff"], 2)` = `r round(2 * univ_model_compar["m8", "se_diff"], 2)`) away from 0.

### Conclusion

The fact that the full model turned out to be the best-fitting one suggests that the data really are best fit by this model, and that the patient term and the interaction terms really should remain in the model.

```{r BestModel3wayInteractPlot, anchor=FIGREF, fig.width = 12}
wrap_plots(plot(conditional_effects(m9,
                               dpar = "mu",
                               effects = "patient:cond",
                               conditions = conditions),
                plot = FALSE)[[1]] + 
             theme(legend.position = "none"),
           plot(conditional_effects(m9,
                               dpar = "sigma",
                               effects = "patient:cond",
                               conditions = conditions),
                plot = FALSE)[[1]] + 
             theme(legend.position = "none"), 
           plot(conditional_effects(m9,
                               dpar = "alpha",
                               effects = "patient:cond",
                               conditions = conditions),
                plot = FALSE)[[1]]) + 
             plot_annotation(tag_levels = "A")
```

`r figr("BestModel3wayInteractPlot", type = FIGREF)`. *Three-way interaction plots of the three modeled parameters $\mu$, $\sigma$, and $\alpha$ as estimated by the best-fitting model. The x axis shows group membership (0 = healthy subjects, 1 = patients). The instruction conditions are color-coded (red = controlled strokes, green = normal strokes), and the facets show the side (1 = dominant, 2 = non-dominant).*

***

`r figr("BestModel3wayInteractPlot")`A suggests that $\mu$ is higher for healthy subjects than for patients, and higher for controlled strokes than for normal strokes which is really odd on an intuitive level and seems contradictive (at least to me). I would've expected `transSC` to 

`r figr("BestModel3wayInteractPlot")`N might clarify why this is the case, because it shows a higher unexplained variation in the data for controlled strokes as compared to normal strokes. 

 (see *e.g.*, [here](https://en.wikipedia.org/wiki/Skewness#Introduction), 

On a different level of understanding these results mean that `transSC` is lower in the normal strokes, with almost no skewness (alpha is close to zero) and lower spread than in controlled strokes.


## Adding the Response `transFlat` 

In the following, the descriptor `transFlat` is added as an outcome to our model. Technically speaking, we would need to re-start our modeling attempt with the Null model and work our way up to the 'best' model as we have done with `transSC`. This is necessary because we cannot just assume that with an additional outcome (which will actually become three additional outcomes: mu, alpha and sigma) will be best explained by the same model as was with just one outcome variable.

But we take a short cut here and just add `transFlat` to the best model of `transSC`.

To be able to see whether skewness and spread are depending on both experimental manipulation and arm, the model formulas for 'sigma' and 'alpha' are updated accordingly:

```{r}
(m10_form <-bf(mvbind(transSC, transFlat) ~ cond + arm + 
                 (1|p|cond) +
                 (1|q|arm) + 
                 (1|r|subj),
               sigma ~ cond + arm,
               alpha ~ arm + cond))
```

The prior probability on the individual intercepts needs to reflect that there are now two response variables:

```{r}
(m10_prior <- c(
  set_prior("lkj(2)",         class = "cor"),
  
  set_prior("normal(0, 0.1)", class = "sd",        resp = "transFlat"),
  set_prior("normal(0, 2)",   class = "b",         resp = "transFlat", dpar = "alpha"),
  set_prior("normal(0, 2)",   class = "Intercept", resp = "transFlat", dpar = "alpha"),
  set_prior("normal(0, 1)",   class = "Intercept", resp = "transFlat", dpar = "sigma"),
  set_prior("normal(0, 1)",   class = "b",         resp = "transFlat", dpar = "sigma"),
  
  set_prior("normal(0, 0.1)", class = "sd",        resp = "transSC"),
  set_prior("normal(0, 2)",   class = "b",         resp = "transSC",   dpar = "alpha"),
  set_prior("normal(0, 2)",   class = "Intercept", resp = "transSC",   dpar = "alpha"),
  set_prior("normal(0, 2)",   class = "Intercept", resp = "transSC",   dpar = "sigma"),
  set_prior("normal(0, 2)",   class = "b",         resp = "transSC",   dpar = "sigma")
))
```

```{r}
if (MODEL) {
  t <- Sys.time()
  m10 <- brm(m10_form,            
            prior = m10_prior,
            family = skew_normal(),
            data = drum_beats,
            inits = "0")
  print(Sys.time() - t)
  m10 <- add_criterion(m10, 
                      "loo",
                      reloo = TRUE)
  save(m10, 
       file = "m10.rda")
} else {
  # load("m10.rda")
}
```

***

`r figr("m10_summary", type = TABREF)`. *Model summary.*

```{r m10_summary, achor = TABREF}
# (m10_summary <- summary(m10, 
#                        priors = TRUE))
```

In the Population-Level Effects section of `r figr("m10_summary")` are now three estimates for the skewness parameter alpha, as well as three estimates for spread ('sigma').

```{r m10_ppcheck, anchor=FIGREF}
# pp_check(m10, resp = "transSC", nsamples = 100)
# pp_check(m10, resp = "transFlat", nsamples = 100)
```

`r figr("m10_ppcheck", type = FIGREF)`. *Posterior predictive check. The thick blue line shows the distribution of the empirical data. The thin blue lines are one-hundred realizations of data generated from parameters estimated by the model.*

***

```{r m10_condPlot, anchor=FIGREF}
# , fig.width=12, fig.height=12
# p <- plot(conditional_effects(m10,
#                               dpar = "mu"),
#           plot = FALSE)
# p1 <- wrap_plots(p[[1]] + xlab("") +
#                    p[[2]] + xlab("") + ylab("") +
#                    p[[3]] + xlab("") + ylab("") + theme(legend.position = "none"))
# p <- plot(conditional_effects(m10,
#                               dpar = "alpha"),
#           plot = FALSE)
# p2 <- wrap_plots(p[[1]] + xlab("") +
#                    p[[2]] + xlab("") + ylab("") +
#                    p[[3]] + xlab("") + ylab("") + theme(legend.position = "none"))
# p <- plot(conditional_effects(m10,
#                               dpar = "sigma"),
#           plot = FALSE)
# p3 <- wrap_plots(p[[1]] +
#                    p[[2]] + ylab("") +
#                    p[[3]] + ylab("") + theme(legend.position = "bottom"))
# wrap_plots(p1, p2, p3, 
#            ncol = 1) +
#   plot_annotation(tag_levels = "A")
```

`r figr("m10_condPlot", type = FIGREF)`. *Conditional plots.*

***

In `r figr("m10_condPlot")` there is a clear difference in estimated mean ('mu') of $transSC$ conditional on instruction (A), but not on arm (B). Consequently, there is no interaction between instruction and arm (C). There is a difference in estimated skewness ('alpha') both between instructions (D) and sides (E), but with opposing trends. Nevertheless, there is no interaction between them (F). 'sigma' shows a clear difference between instructions (G) as well as for side (H), but albeit their opposing trends, there is no interaction (I).


## transCrest

# System Setup

Data wrangling and analyses were carried out with the statistical package `R` [`r version$version.string`; @RCT2020]. Bayesian modeling was done with the package `brms` [@Buerkner2017;@Buerkner2018] which uses the probabilistic language Stan as back end [@Carpenter2017]. Plots were done with the packages `bayesplot` [@Gabry2020] and `ggplot2` [@Wickham2016].

# References 
